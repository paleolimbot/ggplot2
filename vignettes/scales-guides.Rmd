---
title: "Scales and Guides Brainstorming"
output: rmarkdown::html_document
vignette: >
  %\VignetteIndexEntry{Scales and Guides Brainstorming}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(ggplot2)
library(grid)
library(gtable)
draw <- gridExtra::grid.arrange
```

## ggplot2 1d data spaces

- Untransformed data space

```{r}
p <- ggplot(mpg, aes(class, cty)) + geom_boxplot()
p
```

- Transformed data space

```{r}
p + scale_y_log10(breaks = seq(10, 35, 5), labels = format(log10(seq(10, 35, 5))))
```

- Mapped data space

```{r}
p + 
  scale_y_log10(breaks = seq(10, 35, 5), labels = format(log10(seq(10, 35, 5)))) +
  scale_x_discrete(labels = 1:7)
```

- Rescaled data space

```{r}
p + 
  scale_y_log10(
    breaks = seq(10, 35, 5), 
    labels = format(scales::rescale(log10(seq(10, 35, 5)), from = c(0.9247512, 1.5735593)))
  ) +
  scale_x_discrete(
    labels = format(scales::rescale(1:7, from = c(0.4, 7.6)))
  )
```

## Scales and guides

```{r}
p <- ggplot(
  mpg, 
  aes(class, cty, col = displ, shape = drv)
) + 
  geom_boxplot(aes(fill = drv)) +
  geom_point(position = position_jitterdodge(jitter.width = 0.2)) 
p
```

Scales:

- colour (continuous)
- fill (discrete)
- shape (discrete)
- **x (discrete)**
- **y (continuous)**

Guides:

- colour (`guide_colourbar()` with `position = "right"`)
- fill (`guide_legend()` with `position = "right"`)
- shape (`guide_legend()` with `position = "right"`, merged with fill guide)
- **x ("axis" guide with `position = "bottom"`)**
- **y ("axis" guide with with `position = "left"`)**
- **x and y ("grid" guide with with `position = "background"`)**

## Position guides and coordinate systems

```{r}
p + coord_polar()
```

Here, the position guides are:

- x ("clock" guide with `position = "foreground"`)
- y ("axis" guide with  `position = "left"`, with a transform applied in rescaled data space)\*
- x + y ("target" guide with `position = "background"`)

## coord_trans()

```{r}
p + 
  coord_trans(y = "log10")
```

Here, the position guides are:

- x ("axis" guide with `position = "bottom"`)
- y ("axis" guide with `position = "left"` with a transformation applied in transformed data space)
- x + y ("grid" guide with `position = "background"`, with a transformation applied to "y" in transformed data space)

## Second axes

```{r}
p +
  scale_y_continuous(
    sec.axis = sec_axis(
      ~235.215 / ., 
      name = "L/100 km"
    )
  )
```

Here, the position guides are:

- x ("axis" guide with `position = "bottom"`)
- y ("axis" guide with `position = "left"`)
- y ("axis" guide with `position = "right"` with a transform applied in untransformed data space that calculates breaks and labels at draw time)
- x + y ("grid" guide with `position = "background"`)


## Rotated coordinate systems

```{r}
ggspatial::load_longlake_data()
ggplot(longlake_depthdf) +
  geom_sf() +
  coord_sf(crs = 26910) +
  scale_x_continuous(expand = expand_scale(2)) 
```

- x + y (with `position = c("left", "bottom", "background")`)

## Things that ggplot2 might be able to do

### Smarter handling of overlappling labels

```{r}
p +
  scale_y_continuous(breaks = scales::extended_breaks(n = 100))
```

Could handle this by:

- dodging overlaps into multiple columns (user defined number of cols)

```{r}
dodgedLabelGrob <- function(labels, breaks, n_rows = 1) {
  label_info <- tibble::tibble(
    labels,
    breaks,
    row = rep_len(seq_len(n_rows), length(labels))
  )

  rows <- lapply(split(label_info, label_info$row), function(info) {
    ggplot2:::titleGrob(
      info$labels, x = info$breaks, y = unit(0.5, "npc"), 
      hjust = NULL, vjust = NULL
    )
  })
  heights <- do.call(unit.c, lapply(rows, grobHeight))
  gtable_col("axis", rows, heights = heights)
}

test_dodge_n <- function(n, n_rows = 1) {
  labels <- sprintf("%d,000,000", seq_len(n))
  breaks <- scales::rescale(seq_len(n), to = c(-0.5, 0.5)) * 0.8 + 0.5
  ticks <- pointsGrob(x = breaks, y = rep(0.5, n), default.units = "npc")

  rbind(
    gtable_col("ticks", list(ticks), heights = unit(1, "cm")),
    dodgedLabelGrob(labels, breaks, n_rows)
  )
}

draw(test_dodge_n(10, n_rows = 2))
```

- removing alternate labels (bisecting inwards...probably only makes sense for continuous scales, use `check.overlap` and change order)

```{r}
priority <- function(n) {
  if(n <= 0) return(numeric(0))
  
  first <- 1
  last <- n
  middle <- (n + 1) %/% 2
  
  order <- c(
    first, last, middle, 
    first + priority(middle - first - 1), 
    middle + priority(last - middle - 1)
  )
  unique(order)
}

priority(5)
```

```{r}
test_overlap_n <- function(n) {
  labels <- sprintf("%d,000,000", seq_len(n))
  breaks <- scales::rescale(seq_len(n), to = c(-0.5, 0.5)) * 0.8 + 0.5
  order <- priority(n)
  gTree(children = gList(
    pointsGrob(x = breaks[order], y = rep(0.5, n), default.units = "npc"),
    textGrob(labels[order], x = breaks[order], check.overlap = TRUE, vjust = 2)
  ))
}

draw(test_overlap_n(10))
```

- rotating labels

https://github.com/paleolimbot/tidypaleo/blob/master/R/ggstrat-themes.R#L137-L156

```{r}
test_angle_n <- function(n, angle = 0) {
  labels <- sprintf("%d,000,000", seq_len(n))
  breaks <- scales::rescale(seq_len(n), to = c(-0.5, 0.5)) * 0.8 + 0.5
  
  hjust = if(angle > 0) 1 else if(angle < 0) 0 else 0.5
  vjust = if(abs(angle) == 90) 0.5 else if(abs(angle) != 0) 1 else 1
  
  grobs <- list(
    pointsGrob(x = breaks, y = rep(0.5, n), default.units = "npc"),
    ggplot2:::titleGrob(
      labels, x = breaks, y = rep(1, length(breaks)), 
      hjust = hjust, angle = angle, 
      vjust = vjust
    )
  )
  
  heights <- unit.c(unit(0.5, "cm"), grobHeight(grobs[[2]]))
  gtable_col("axis", grobs, heights = heights)
}

draw(test_angle_n(10, 45))
```



### Minor ticks

```{r}
p +
  annotate("text", x = -Inf, y = seq(12.5, 32.5, by = 5), label = "-", hjust = 1, size = 3) +
  coord_cartesian(clip = "off") +
  theme_classic()
```


### Manual specifiation of tick locations/labels

```{r}
knitr::include_graphics("right_axis_values.png")
```

Might be nice to specify in any of the scale data spaces...original data space here, but transformed data space for something calculated from the layers, mapped for something involving pre coordinate system transformation, or rescaled for putting something at the top/bottom/middle.

### Custom tick marks?

```{r}
p +
  annotate("point", x = -Inf, y = seq(10, 35, by = 5)) +
  coord_cartesian(clip = "off")
```

### Aesthetics applied to tick marks/labels

```{r}
ggplot(mpg, aes(class, hwy, col = class)) +
  geom_jitter()
```

### Multiple position guides on the same side of the plot?

```{r}
knitr::include_graphics("multiple_posigion_guides.png")
```

### Heiarchical scales/axis guides?

(need to find a better example) 

```{r}
knitr::include_graphics("heiarch_scale.png")
```

### hclust scales/gudies?

```{r}
knitr::include_graphics("cor_clust.png")
```
